# 长将/长捉检测机制说明

## 实现方案：宽松版检测

基于您的要求"最宽松的检测，不要太复杂"，我们实现了简化的检测机制。

---

## 📋 检测规则

### 长将检测

**规则：**
- 检查最近**12步**
- 如果其中**10步以上**在将军 → 判负（-10分）

**代码：**
```python
def _check_perpetual_check(self):
    if len(self.check_history) < 12:
        return False

    recent_checks = self.check_history[-12:]
    check_count = sum(1 for check in recent_checks if check)

    return check_count >= 10  # 12步中10步以上将军
```

**例子：**
```
步骤1-12: T F T F T F T F T F T T
          将 应 将 应 将 应 将 应 将 应 将 将
计数: 8次将军 → 不触发（<10）

步骤1-12: T T T T T T T T T T F F
          将 将 将 将 将 将 将 将 将 将 - -
计数: 10次将军 → 触发长将，判负！
```

---

### 长捉检测

**规则：**
- 检查最近**12步**
- 如果其中**10步以上**有捉子动作 → 判负（-10分）

**代码：**
```python
def _check_perpetual_chase(self):
    if len(self.chase_history) < 12:
        return False

    recent_chases = self.chase_history[-12:]
    chase_count = sum(1 for chase in recent_chases if len(chase) > 0)

    return chase_count >= 10  # 12步中10步以上捉子
```

**捉的定义：**
- 下一步能吃掉对方的**无根子**（无保护的棋子）
- 不包括将/帅（将军单独计算）

---

## ✅ 宽松程度分析

### 与标准规则的对比

| 特性 | 标准国规 | 当前实现 |
|------|----------|----------|
| 判定标准 | 循环3次相同局面 | 12步中10步违规 |
| 复杂度 | 需要追踪局面循环 | 简单计数 |
| 严格度 | 严格 | **非常宽松** |
| 误判风险 | 低 | 极低 |

### 宽松之处

1. **允许偶尔将军/捉子**
   - 12步中可以有2步不是将军/捉子
   - 允许战术性的将军、捉子

2. **不检查循环**
   - 不要求回到相同局面
   - 只统计将军/捉子的频率

3. **不区分捉哪个子**
   - 不要求捉"同一个子"
   - 捉任何无根子都计数

4. **步数较多**
   - 需要持续12步才判定
   - 给AI足够的战术空间

---

## 🎯 设计意图

### 为什么这么宽松？

1. **训练初期AI水平低**
   - 不会故意长将/长捉
   - 过严规则会误判

2. **鼓励进攻**
   - 允许多次将军/捉子
   - 不限制战术探索

3. **避免过度惩罚**
   - 只惩罚"明显滥用"的情况
   - 12步中10步以上是极端情况

4. **简单可靠**
   - 代码简单，不易出bug
   - 性能开销小

---

## 📊 触发场景示例

### 会触发长将的情况：

```
红车在底线反复将军，黑将只能左右移动
第1步: 车移动，将军 ✓
第2步: 将躲避，不算将军
第3步: 车回来，将军 ✓
第4步: 将躲避
...连续12步...
→ 如果12步中≥10步在将军，红方判负
```

### 不会触发的情况：

```
正常进攻，偶尔将军
第1步: 将军 ✓
第2步: 对方应将
第3步: 正常走法
第4步: 对方走法
第5步: 将军 ✓
第6步: 对方应将
第7步: 吃子
...
→ 12步中只有2-3次将军，不触发
```

---

## 🔧 测试验证

运行测试：
```bash
python test_perpetual_rules.py
```

**测试结果：**
- ✅ 12步中6步将军 → 不触发
- ✅ 12步中10步将军 → 触发长将
- ✅ 12步中6步捉子 → 不触发
- ✅ 12步中10步捉子 → 触发长捉

---

## 💡 后期改进建议

如果训练到中后期，AI水平提高后出现滥用，可以：

### 选项1: 降低阈值
```python
return check_count >= 8  # 从10改为8，稍微严格一些
```

### 选项2: 减少步数
```python
recent_checks = self.check_history[-10:]  # 从12改为10
return check_count >= 8
```

### 选项3: 完整实现（后期）
- 检测局面循环
- 区分捉同一个子
- 符合完整国规

---

## 📝 总结

当前实现：
- ✅ 最宽松的检测
- ✅ 代码简单可靠
- ✅ 只禁止明显滥用
- ✅ 不影响正常战术
- ✅ 适合训练初期

**符合您的要求：不要太复杂，但保留检测功能！**
